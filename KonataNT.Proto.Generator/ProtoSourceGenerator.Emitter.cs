using System.Text;
using KonataNT.Proto.Generator.Utility;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace KonataNT.Proto.Generator;

public partial class ProtoSourceGenerator
{
    private static void Generate(TypeDeclarationSyntax syntax, Compilation compilation, string? serializationInfoLogDirectoryPath, IGeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null) return;
        
        if (!syntax.IsPartial())
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }
        
        var visitor = new ContextVisitor(context);
        syntax.Accept(visitor);
        
        var sb = new StringBuilder();

        sb.AppendLine(@"
// <auto-generated/>
#nullable enable
#pragma warning disable CS0108 // hides inherited member
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8602 // 
#pragma warning disable CS8604 // Possible null reference argument for parameter
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
#pragma warning disable CS8765 // Nullability of type of parameter
#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
#pragma warning disable CA1050 // Declare types in namespaces.

using System;
using KonataNT.Proto;
using KonataNT.Proto.Serialization;
");

        string visibility = syntax.GetVisibility();
        sb.AppendLine($"namespace {typeSymbol.ContainingNamespace.ToDisplayString()};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated by KonataNT.Proto.Generator");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"{visibility} partial class {typeSymbol.Name}");
        sb.AppendLine("{");
        
        EmitSerializer(syntax, visitor, sb);
        sb.AppendLine();
        EmitDeserializer(syntax, visitor, sb);
        
        sb.AppendLine("}");

        string code = sb.ToString();
        context.AddSource($"{typeSymbol.Name}.ProtoContracted.g.cs", code);
    }
    
    private static void EmitSerializer(TypeDeclarationSyntax syntax, ContextVisitor context, StringBuilder sb)
    {
        sb.AppendLine("    public Span<byte> Serialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        var writer = new ProtoWriter();");

        foreach (var meta in context.List)
        {
            if (meta.IsNested)
            {
                string variableName = meta.Name.ToLower() + "Serialized";
                sb.AppendLine($"        var {variableName} = {meta.Name}.Serialize();");   // recursive call
            }
            else
            {
                sb.AppendLine($"        writer.WriteHead(WireType.{meta.WireType}, {meta.Tag});");
            }
        }
        
        sb.AppendLine("        return Array.Empty<byte>();");
        sb.AppendLine("    }");
    }
    
    private static void EmitDeserializer(TypeDeclarationSyntax syntax, ContextVisitor context, StringBuilder sb)
    {
        string className = syntax.Identifier.Text;
        
        sb.AppendLine($"    public static {className} Deserialize(ReadOnlySpan<byte> buffer)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {className}();");
        sb.AppendLine("    }");
    }
}