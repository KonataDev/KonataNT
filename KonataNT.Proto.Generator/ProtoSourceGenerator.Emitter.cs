using System.Text;
using KonataNT.Proto.Generator.Meta;
using KonataNT.Proto.Generator.Utility;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace KonataNT.Proto.Generator;

public partial class ProtoSourceGenerator
{
    private static void Generate(TypeDeclarationSyntax syntax, Compilation compilation, string? serializationInfoLogDirectoryPath, IGeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null) return;
        
        if (!syntax.IsPartial())
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }
        
        var visitor = new ContextVisitor(context);
        syntax.Accept(visitor);
        
        var sb = new StringBuilder();

        sb.AppendLine(@"
// <auto-generated/>
#nullable enable
#pragma warning disable CS0108 // hides inherited member
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8602 // 
#pragma warning disable CS8604 // Possible null reference argument for parameter
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
#pragma warning disable CS8765 // Nullability of type of parameter
#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
#pragma warning disable CA1050 // Declare types in namespaces.

using System;
using KonataNT.Proto;
using KonataNT.Proto.Serialization;
");

        string visibility = syntax.GetVisibility();
        sb.AppendLine($"namespace {typeSymbol.ContainingNamespace.ToDisplayString()};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated by KonataNT.Proto.Generator");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"{visibility} partial class {typeSymbol.Name} : IProto");
        sb.AppendLine("{");
        
        EmitSerializer(syntax, visitor, sb);
        sb.AppendLine();
        EmitDeserializer(syntax, visitor, sb);
        
        sb.AppendLine("}");

        string code = sb.ToString();
        context.AddSource($"{typeSymbol.Name}.ProtoContracted.g.cs", code);
    }
    
    private static void EmitSerializer(TypeDeclarationSyntax syntax, ContextVisitor context, StringBuilder sb)
    {
        sb.AppendLine("    public byte[] Serialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        using var stream = new MemoryStream();");
        sb.AppendLine("        var writer = new ProtoWriter(stream);");
        sb.AppendLine();

        foreach (var meta in context.List)
        {
            if (meta.IsEnumerable)
            {
                sb.AppendLine($"        foreach (var element in {meta.Name})");
                sb.AppendLine( "        {");
                EmitMemberSerialize(sb, meta, "element", true);
                sb.AppendLine( "        }");
            }
            else
            {
                EmitMemberSerialize(sb, meta, meta.Name, false);
            }
            sb.AppendLine();
        }

        sb.AppendLine("        writer.Flush();");
        sb.AppendLine("        return stream.ToArray();");
        sb.AppendLine("    }");
    }

    private static void EmitMemberSerialize(StringBuilder sb, ProtoMemberMeta meta, string name, bool indent)
    {
        string i = indent ? "    " : "";
        if (meta.IsNullable)
        {
            i += "    ";
            sb.AppendLine($"        if ({name} != null)");
            sb.AppendLine("        {");
        }
        
        if (meta.IsNested)
        {
            string variableName = name.ToLower() + "Serialized";
            sb.AppendLine($"{i}        var {variableName} = {name}.Serialize();");   // recursive call
            sb.AppendLine($"{i}        writer.WriteHead(WireType.LengthDelimited, {meta.Tag});");
            sb.AppendLine($"{i}        writer.WriteLengthDelimited({variableName}.AsSpan());");
        }
        else
        {
            
            sb.AppendLine($"{i}        writer.WriteHead(WireType.{meta.WireType}, {meta.Tag});");

            string func = meta.WireType switch
            {
                WireType.VarInt => "WriteVarInt",
                WireType.LengthDelimited => "WriteLengthDelimited",
                _ => throw new InvalidOperationException()
            };

            if (meta is { IsValueType: true, IsNullable: true }) name += ".Value";
            sb.AppendLine($"{i}        writer.{func}({name});");
        }
        
        if (meta.IsNullable) sb.AppendLine("        }");
    }
    
    private static void EmitDeserializer(TypeDeclarationSyntax syntax, ContextVisitor context, StringBuilder sb)
    {
        string className = syntax.Identifier.Text;
        
        sb.AppendLine($"    public static IProto Deserialize(byte[] buffer)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {className}();");
        sb.AppendLine("    }");
    }
}